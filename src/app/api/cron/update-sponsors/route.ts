import {NextResponse} from 'next/server'
import {sql, client} from '~/db'
import {getGithubSponsors} from '~/gh/sponsors'

export const dynamic = 'force-dynamic'

export async function GET(_request: Request) {
  const sponsoree = process.env.DEVELOPER_GITHUB_LOGIN || 'mmkal'
  const sponsors = await getGithubSponsors({sponsoree})
  const records = sponsors.map(s => ({
    sponsor_login: s.id,
    sponsoree_login: sponsoree,
    github_type: s.type,
    expiry: new Date(Date.now() + 1000 * 60 * 60 * 24 * 28), // 4 weeks
    monthly_amount_usd: null, // dunno this yet
  }))
  const inserted = await client.any(sql<queries.Sponsor>`
    insert into sponsors (sponsor_login, sponsoree_login, github_type, expiry, monthly_amount_usd)
    select sponsor_login, sponsoree_login, github_type, expiry, monthly_amount_usd
    from jsonb_populate_recordset(
      null::sponsors,
      ${JSON.stringify(records)}
    )
    on conflict (sponsor_login, sponsoree_login)
    do update set
      github_type = excluded.github_type,
      monthly_amount_usd = excluded.monthly_amount_usd,
      expiry = excluded.expiry,
      updated_at = current_timestamp
    returning id, sponsor_login, sponsoree_login, expiry, created_at, updated_at
  `)

  const credits = await client.any(sql<queries.UsageCredit>`
    insert into usage_credits (github_login, expiry, sponsor_id, reason)
    select github_login, expiry, sponsor_id, reason
    from jsonb_populate_recordset(
      null::usage_credits,
      ${JSON.stringify(
        inserted.map(sp => ({
          github_login: sp.sponsor_login,
          expiry: sp.expiry,
          reason: 'sponsor',
          sponsor_id: sp.id,
        })),
      )}
    )
    on conflict (github_login, reason) 
    do update set
      expiry = excluded.expiry,
      sponsor_id = excluded.sponsor_id,
      updated_at = current_timestamp
    returning id, github_login, expiry, sponsor_id, reason, created_at, updated_at
  `)

  console.log({inserted, credits})

  return NextResponse.json({
    inserted: inserted.map(i => i.id),
    credits: credits.map(c => c.id),
  })
}

export declare namespace queries {
  // Generated by @pgkit/typegen

  /** - query: `insert into sponsors (sponsor_login, spo... [truncated] ...ee_login, expiry, created_at, updated_at` */
  export interface Sponsor {
    /** column: `public.sponsors.id`, not null: `true`, regtype: `prefixed_ksuid` */
    id: import('~/db').Id<'sponsors'>

    /** column: `public.sponsors.sponsor_login`, not null: `true`, regtype: `text` */
    sponsor_login: string

    /** column: `public.sponsors.sponsoree_login`, not null: `true`, regtype: `text` */
    sponsoree_login: string

    /** column: `public.sponsors.expiry`, not null: `true`, regtype: `timestamp with time zone` */
    expiry: Date

    /** column: `public.sponsors.created_at`, not null: `true`, regtype: `timestamp with time zone` */
    created_at: Date

    /** column: `public.sponsors.updated_at`, not null: `true`, regtype: `timestamp with time zone` */
    updated_at: Date
  }

  /** - query: `insert into usage_credits (github_login,... [truncated] ...onsor_id, reason, created_at, updated_at` */
  export interface UsageCredit {
    /** column: `public.usage_credits.id`, not null: `true`, regtype: `prefixed_ksuid` */
    id: import('~/db').Id<'usage_credits'>

    /** column: `public.usage_credits.github_login`, not null: `true`, regtype: `text` */
    github_login: string

    /** column: `public.usage_credits.expiry`, not null: `true`, regtype: `timestamp with time zone` */
    expiry: Date

    /** column: `public.usage_credits.sponsor_id`, regtype: `prefixed_ksuid` */
    sponsor_id: string | null

    /** column: `public.usage_credits.reason`, not null: `true`, regtype: `text` */
    reason: string

    /** column: `public.usage_credits.created_at`, not null: `true`, regtype: `timestamp with time zone` */
    created_at: Date

    /** column: `public.usage_credits.updated_at`, not null: `true`, regtype: `timestamp with time zone` */
    updated_at: Date
  }
}
