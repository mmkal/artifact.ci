import AdmZip from 'adm-zip'
import mime from 'mime'
import {Octokit} from 'octokit'
import pMap from 'p-suite/p-map'
import * as path from 'path'
import {z} from 'zod'
import {getEntrypoints} from './signed-url/route'
import {getInstallationOctokit} from '~/app/github/events/route'
import {client, sql} from '~/db'
import {createStorageClient} from '~/storage/supabase'

export async function* storeArtifact(input: {artifactId: string}) {
  console.log(`starting ${input.artifactId} <<<<<<<<`)
  const artifact = await client.one(sql<queries.Artifact>`
    select a.*, gi.github_id as installation_github_id, r.owner as repo_owner, r.name as repo_name
    from artifacts a
    join github_installations gi on gi.id = a.installation_id
    join repos r on r.id = a.repo_id
    where a.id = ${input.artifactId}
  `)
  console.log(`found ${input.artifactId} <<<<<<<<`)
  yield {
    stage: 'found' as const,
    message: `Got artifact ${artifact?.name}`,
    progress: 5,
  }

  console.log(`octokit ${input.artifactId}  <<<<<<<<`)
  const octokit = await getInstallationOctokit(artifact.installation_github_id)
  console.log(`got octokit ${input.artifactId} <<<<<<<<`)
  const zipRes = await octokit.request(`GET ${artifact.download_url}`, {
    mediaType: {format: 'zip'},
  })
  console.log(`got zip ${input.artifactId} <<<<<<<<`)
  yield {
    stage: 'downloaded' as const,
    message: `Downloaded ${path.basename(artifact.download_url)} ${artifact.name}`,
    progress: 10,
  }
  console.log(`parsed zip ${input.artifactId} <<<<<<<<`)
  const arrayBuffer = z.instanceof(ArrayBuffer).parse(zipRes.data)
  const zip = new AdmZip(Buffer.from(arrayBuffer))
  const entries = zip.getEntries()
  console.log(`got entries ${entries.length} <<<<<<<<`)
  yield {
    stage: 'extracted' as const,
    message: `Extracted ${entries.length} entries from ${artifact.name}`,
    progress: 10 + 90 / (entries.length + 2),
  }

  // const artifactPathPrefix = `github/artifacts/${new URL(artifact.download_url).pathname}`
  const artifactPathPrefix = [
    'github/artifacts',
    `${artifact.repo_owner}/${artifact.repo_name}`,
    artifact.created_at.toISOString().split(/\D/).slice(0, 3).join('/'), // date part in subfolders so when debugging can navigate to year/month/day
    artifact.created_at.toISOString().split('T')[1].replaceAll(':', '.'), // time part as a dot-separated string
    artifact.name,
    artifact.id,
  ].join('/')
  const storage = createStorageClient()
  const uploads = await pMap(
    entries,
    async entry => {
      const mimeType = mime.getType(entry.name) || 'text/plain'
      const objectPath = `${artifactPathPrefix}/${artifact.name}/${entry.name}`
      const obj = await storage.object
        .bucketName('github/artifacts')
        .wildcard(objectPath)
        .post({
          content: {[mimeType]: entry.getData()},
        })

      return {entry, obj, path: objectPath, mimeType}
    },
    {concurrency: 10},
  )

  yield {
    stage: 'uploaded' as const,
    message: `Uploaded ${uploads.length} files`,
    progress: 10 + 90 / (entries.length + 2),
  }

  const inserts = await client.any(sql<queries.ArtifactEntry>`
    insert into artifact_entries (
      artifact_id,
      entry_name,
      aliases,
      storage_object_id
    )
    select artifact_id, entry_name, aliases, storage_object_id
    from jsonb_populate_recordset(
      null::artifact_entries,
      ${JSON.stringify(
        uploads.map(u => ({
          artifact_id: input.artifactId,
          entry_name: u.entry.entryName,
          aliases: getEntrypoints([u.entry.entryName]).flatAliases,
          storage_object_id: u.obj.json.Id,
        })),
      )}
    )
    -- commented out to make weird cases visible for now
    -- on conflict do nothing
    returning *
  `)

  yield {
    stage: 'complete' as const,
    message: `Created ${inserts.length} entries`,
    progress: 100,
  }
  //   yield {stage: 'download', progress: 0}
  //   await new Promise(r => setTimeout(r, 1000))
  //   yield {stage: 'download', progress: 50}
  //   await new Promise(r => setTimeout(r, 1000))
  //   yield {stage: 'download', progress: 100}

  //   await new Promise(r => setTimeout(r, 500))

  //   yield {stage: 'extract', progress: 0}
  //   await new Promise(r => setTimeout(r, 1000))
  //   yield {stage: 'extract', progress: 50}
  //   await new Promise(r => setTimeout(r, 1000))
  //   yield {stage: 'extract', progress: 100}

  //   await new Promise(r => setTimeout(r, 500))

  //   yield {stage: 'upload', progress: 0}
  //   await new Promise(r => setTimeout(r, 1000))
  //   yield {stage: 'upload', progress: 50}
  //   await new Promise(r => setTimeout(r, 1000))
  //   yield {stage: 'upload', progress: 100}

  await client.query(sql<queries.Artifact>`
    insert into artifact_entries (artifact_id, entry_name, )
  `)
}

export declare namespace queries {
  // Generated by @pgkit/typegen

  /** - query: `select a.*, gi.github_id as installation... [truncated] ...os r on r.id = a.repo_id where a.id = $1` */
  export interface Artifact {
    /** column: `public.artifacts.id`, not null: `true`, regtype: `prefixed_ksuid` */
    id: import('~/db').Id<'artifacts'>

    /** column: `public.artifacts.repo_id`, not null: `true`, regtype: `prefixed_ksuid` */
    repo_id: string

    /** column: `public.artifacts.name`, not null: `true`, regtype: `text` */
    name: string

    /** column: `public.artifacts.created_at`, not null: `true`, regtype: `timestamp with time zone` */
    created_at: Date

    /** column: `public.artifacts.updated_at`, not null: `true`, regtype: `timestamp with time zone` */
    updated_at: Date

    /** column: `public.artifacts.download_url`, not null: `true`, regtype: `text` */
    download_url: string

    /** column: `public.artifacts.github_id`, not null: `true`, regtype: `bigint` */
    github_id: number

    /** column: `public.artifacts.installation_id`, not null: `true`, regtype: `prefixed_ksuid` */
    installation_id: string

    /** column: `public.github_installations.github_id`, not null: `true`, regtype: `bigint` */
    installation_github_id: number

    /** column: `public.repos.owner`, not null: `true`, regtype: `text` */
    repo_owner: string

    /** column: `public.repos.name`, not null: `true`, regtype: `text` */
    repo_name: string
  }

  /** - query: `insert into artifact_entries ( artifact_... [truncated] ...ow -- on conflict do nothing returning *` */
  export interface ArtifactEntry {
    /** column: `public.artifact_entries.id`, not null: `true`, regtype: `prefixed_ksuid` */
    id: import('~/db').Id<'artifact_entries'>

    /** column: `public.artifact_entries.artifact_id`, not null: `true`, regtype: `prefixed_ksuid` */
    artifact_id: string

    /** column: `public.artifact_entries.entry_name`, not null: `true`, regtype: `text` */
    entry_name: string

    /** column: `public.artifact_entries.aliases`, not null: `true`, regtype: `text[]` */
    aliases: string[]

    /** column: `public.artifact_entries.storage_object_id`, not null: `true`, regtype: `uuid` */
    storage_object_id: string

    /** column: `public.artifact_entries.created_at`, not null: `true`, regtype: `timestamp with time zone` */
    created_at: Date

    /** column: `public.artifact_entries.updated_at`, not null: `true`, regtype: `timestamp with time zone` */
    updated_at: Date
  }
}
